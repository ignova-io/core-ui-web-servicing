{"version":3,"file":"static/js/9255.cc6b25e5.chunk.js","mappings":"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","sources":["../node_modules/react-map-gl/src/components/use-map.tsx","../node_modules/react-map-gl/src/utils/deep-equal.ts","../node_modules/react-map-gl/src/utils/transform.ts","../node_modules/react-map-gl/src/utils/style-utils.ts","../node_modules/react-map-gl/src/mapbox/mapbox.ts","../node_modules/react-map-gl/src/mapbox/create-ref.ts","../node_modules/react-map-gl/src/utils/use-isomorphic-layout-effect.ts","../node_modules/react-map-gl/src/utils/set-globals.ts","../node_modules/react-map-gl/src/components/map.tsx","../node_modules/react-map-gl/src/utils/apply-react-style.ts","../node_modules/react-map-gl/src/components/marker.ts","../node_modules/react-map-gl/src/components/popup.ts","../node_modules/react-map-gl/src/components/use-control.ts","../node_modules/react-map-gl/src/components/attribution-control.ts","../node_modules/react-map-gl/src/components/fullscreen-control.tsx","../node_modules/react-map-gl/src/components/geolocate-control.ts","../node_modules/react-map-gl/src/components/navigation-control.ts","../node_modules/react-map-gl/src/components/scale-control.ts","../node_modules/react-map-gl/src/utils/assert.ts","../node_modules/react-map-gl/src/components/layer.ts","../node_modules/react-map-gl/src/components/source.ts","../node_modules/react-map-gl/src/exports-mapbox.ts"],"sourcesContent":["import * as React from 'react';\nimport {useState, useCallback, useMemo, useContext} from 'react';\n\nimport {MapRef} from '../mapbox/create-ref';\nimport {MapContext} from './map';\nimport {MapInstance} from '../types';\n\ntype MountedMapsContextValue = {\n  maps: {[id: string]: MapRef<MapInstance>};\n  onMapMount: (map: MapRef<MapInstance>, id: string) => void;\n  onMapUnmount: (id: string) => void;\n};\n\nexport const MountedMapsContext = React.createContext<MountedMapsContextValue>(null);\n\nexport const MapProvider: React.FC<{children?: React.ReactNode}> = props => {\n  const [maps, setMaps] = useState<{[id: string]: MapRef<MapInstance>}>({});\n\n  const onMapMount = useCallback((map: MapRef<MapInstance>, id: string = 'default') => {\n    setMaps(currMaps => {\n      if (id === 'current') {\n        throw new Error(\"'current' cannot be used as map id\");\n      }\n      if (currMaps[id]) {\n        throw new Error(`Multiple maps with the same id: ${id}`);\n      }\n      return {...currMaps, [id]: map};\n    });\n  }, []);\n\n  const onMapUnmount = useCallback((id: string = 'default') => {\n    setMaps(currMaps => {\n      if (currMaps[id]) {\n        const nextMaps = {...currMaps};\n        delete nextMaps[id];\n        return nextMaps;\n      }\n      return currMaps;\n    });\n  }, []);\n\n  return (\n    <MountedMapsContext.Provider\n      value={{\n        maps,\n        onMapMount,\n        onMapUnmount\n      }}\n    >\n      {props.children}\n    </MountedMapsContext.Provider>\n  );\n};\n\nexport type MapCollection<MapT extends MapInstance> = {\n  [id: string]: MapRef<MapT> | undefined;\n  current?: MapRef<MapT>;\n};\n\nexport function useMap<MapT extends MapInstance>(): MapCollection<MapT> {\n  const maps = useContext(MountedMapsContext)?.maps;\n  const currentMap = useContext(MapContext);\n\n  const mapsWithCurrent = useMemo(() => {\n    return {...maps, current: currentMap?.map};\n  }, [maps, currentMap]);\n\n  return mapsWithCurrent as MapCollection<MapT>;\n}\n","import type {PointLike} from '../types';\n\n/**\n * Compare two points\n * @param a\n * @param b\n * @returns true if the points are equal\n */\nexport function arePointsEqual(a?: PointLike, b?: PointLike): boolean {\n  const ax = Array.isArray(a) ? a[0] : a ? a.x : 0;\n  const ay = Array.isArray(a) ? a[1] : a ? a.y : 0;\n  const bx = Array.isArray(b) ? b[0] : b ? b.x : 0;\n  const by = Array.isArray(b) ? b[1] : b ? b.y : 0;\n  return ax === bx && ay === by;\n}\n\n/* eslint-disable complexity */\n/**\n * Compare any two objects\n * @param a\n * @param b\n * @returns true if the objects are deep equal\n */\nexport function deepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true;\n  }\n  if (!a || !b) {\n    return false;\n  }\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b) || a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  } else if (Array.isArray(b)) {\n    return false;\n  }\n  if (typeof a === 'object' && typeof b === 'object') {\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n    for (const key of aKeys) {\n      if (!b.hasOwnProperty(key)) {\n        return false;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n","import type {MapboxProps} from '../mapbox/mapbox';\nimport type {Transform, ViewState} from '../types';\nimport {deepEqual} from './deep-equal';\n\n/**\n * Make a copy of a transform\n * @param tr\n */\nexport function cloneTransform(tr: Transform): Transform {\n  const newTransform = tr.clone();\n  // Work around mapbox bug - this value is not assigned in clone(), only in resize()\n  newTransform.pixelsToGLUnits = tr.pixelsToGLUnits;\n  return newTransform;\n}\n\n/**\n * Copy projection from one transform to another. This only applies to mapbox-gl transforms\n * @param src the transform to copy projection settings from\n * @param dest to transform to copy projection settings to\n */\nexport function syncProjection(src: Transform, dest: Transform): void {\n  if (!src.getProjection) {\n    return;\n  }\n  const srcProjection = src.getProjection();\n  const destProjection = dest.getProjection();\n\n  if (!deepEqual(srcProjection, destProjection)) {\n    dest.setProjection(srcProjection);\n  }\n}\n\n/**\n * Capture a transform's current state\n * @param transform\n * @returns descriptor of the view state\n */\nexport function transformToViewState(tr: Transform): ViewState {\n  return {\n    longitude: tr.center.lng,\n    latitude: tr.center.lat,\n    zoom: tr.zoom,\n    pitch: tr.pitch,\n    bearing: tr.bearing,\n    padding: tr.padding\n  };\n}\n\n/* eslint-disable complexity */\n/**\n * Mutate a transform to match the given view state\n * @param transform\n * @param viewState\n * @returns true if the transform has changed\n */\nexport function applyViewStateToTransform(tr: Transform, props: MapboxProps): boolean {\n  const v: Partial<ViewState> = props.viewState || props;\n  let changed = false;\n\n  if ('zoom' in v) {\n    const zoom = tr.zoom;\n    tr.zoom = v.zoom;\n    changed = changed || zoom !== tr.zoom;\n  }\n  if ('bearing' in v) {\n    const bearing = tr.bearing;\n    tr.bearing = v.bearing;\n    changed = changed || bearing !== tr.bearing;\n  }\n  if ('pitch' in v) {\n    const pitch = tr.pitch;\n    tr.pitch = v.pitch;\n    changed = changed || pitch !== tr.pitch;\n  }\n  if (v.padding && !tr.isPaddingEqual(v.padding)) {\n    changed = true;\n    tr.padding = v.padding;\n  }\n  if ('longitude' in v && 'latitude' in v) {\n    const center = tr.center;\n    // @ts-ignore\n    tr.center = new center.constructor(v.longitude, v.latitude);\n    changed = changed || center !== tr.center;\n  }\n  return changed;\n}\n","import {ImmutableLike, MapStyle} from '../types';\n\nconst refProps = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];\n\n// Prepare a map style object for diffing\n// If immutable - convert to plain object\n// Work around some issues in older styles that would fail Mapbox's diffing\nexport function normalizeStyle(\n  style: string | MapStyle | ImmutableLike<MapStyle>\n): string | MapStyle {\n  if (!style) {\n    return null;\n  }\n  if (typeof style === 'string') {\n    return style;\n  }\n  if ('toJS' in style) {\n    style = style.toJS();\n  }\n  if (!style.layers) {\n    return style;\n  }\n  const layerIndex = {};\n\n  for (const layer of style.layers) {\n    layerIndex[layer.id] = layer;\n  }\n\n  const layers = style.layers.map(layer => {\n    let normalizedLayer: typeof layer = null;\n\n    if ('interactive' in layer) {\n      normalizedLayer = Object.assign({}, layer);\n      // Breaks style diffing :(\n      // @ts-ignore legacy field not typed\n      delete normalizedLayer.interactive;\n    }\n\n    // Style diffing doesn't work with refs so expand them out manually before diffing.\n    // @ts-ignore legacy field not typed\n    const layerRef = layerIndex[layer.ref];\n    if (layerRef) {\n      normalizedLayer = normalizedLayer || Object.assign({}, layer);\n      // @ts-ignore\n      delete normalizedLayer.ref;\n      // https://github.com/mapbox/mapbox-gl-js/blob/master/src/style-spec/deref.js\n      for (const propName of refProps) {\n        if (propName in layerRef) {\n          normalizedLayer[propName] = layerRef[propName];\n        }\n      }\n    }\n\n    return normalizedLayer || layer;\n  });\n\n  // Do not mutate the style object provided by the user\n  return {...style, layers};\n}\n","import {\n  transformToViewState,\n  applyViewStateToTransform,\n  cloneTransform,\n  syncProjection\n} from '../utils/transform';\nimport {normalizeStyle} from '../utils/style-utils';\nimport {deepEqual} from '../utils/deep-equal';\n\nimport type {\n  Transform,\n  ViewState,\n  ViewStateChangeEvent,\n  Point,\n  PointLike,\n  PaddingOptions,\n  MapStyle,\n  ImmutableLike,\n  LngLatBoundsLike,\n  Callbacks,\n  MapEvent,\n  ErrorEvent,\n  MapMouseEvent,\n  MapGeoJSONFeature,\n  MapInstance,\n  MapInstanceInternal\n} from '../types';\n\nexport type MapboxProps<\n  StyleT extends MapStyle = MapStyle,\n  CallbacksT extends Callbacks = {}\n> = Partial<ViewState> &\n  CallbacksT & {\n    // Init options\n    mapboxAccessToken?: string;\n\n    /** Camera options used when constructing the Map instance */\n    initialViewState?: Partial<ViewState> & {\n      /** The initial bounds of the map. If bounds is specified, it overrides longitude, latitude and zoom options. */\n      bounds?: LngLatBoundsLike;\n      /** A fitBounds options object to use only when setting the bounds option. */\n      fitBoundsOptions?: {\n        offset?: PointLike;\n        minZoom?: number;\n        maxZoom?: number;\n        padding?: number | PaddingOptions;\n      };\n    };\n\n    /** If provided, render into an external WebGL context */\n    gl?: WebGLRenderingContext;\n\n    /** For external controller to override the camera state */\n    viewState?: ViewState & {\n      width: number;\n      height: number;\n    };\n\n    // Styling\n\n    /** Mapbox style */\n    mapStyle?: string | StyleT | ImmutableLike<StyleT>;\n    /** Enable diffing when the map style changes\n     * @default true\n     */\n    styleDiffing?: boolean;\n    /** The fog property of the style. Must conform to the Fog Style Specification .\n     * If `undefined` is provided, removes the fog from the map. */\n    fog?: StyleT['fog'];\n    /** Light properties of the map. */\n    light?: StyleT['light'];\n    /** Terrain property of the style. Must conform to the Terrain Style Specification .\n     * If `undefined` is provided, removes terrain from the map. */\n    terrain?: StyleT['terrain'];\n\n    /** Default layers to query on pointer events */\n    interactiveLayerIds?: string[];\n    /** CSS cursor */\n    cursor?: string;\n  };\n\nconst DEFAULT_STYLE = {version: 8, sources: {}, layers: []} as MapStyle;\n\nconst pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nconst settingNames = [\n  'minZoom',\n  'maxZoom',\n  'minPitch',\n  'maxPitch',\n  'maxBounds',\n  'projection',\n  'renderWorldCopies'\n];\nconst handlerNames = [\n  'scrollZoom',\n  'boxZoom',\n  'dragRotate',\n  'dragPan',\n  'keyboard',\n  'doubleClickZoom',\n  'touchZoomRotate',\n  'touchPitch'\n];\n\n/**\n * A wrapper for mapbox-gl's Map class\n */\nexport default class Mapbox<\n  StyleT extends MapStyle = MapStyle,\n  CallbacksT extends Callbacks = {},\n  MapT extends MapInstance = MapInstance\n> {\n  private _MapClass: {new (options: any): MapInstance};\n  // mapboxgl.Map instance\n  private _map: MapInstanceInternal<MapT> = null;\n  // User-supplied props\n  props: MapboxProps<StyleT, CallbacksT>;\n\n  // Mapbox map is stateful.\n  // During method calls/user interactions, map.transform is mutated and\n  // deviate from user-supplied props.\n  // In order to control the map reactively, we shadow the transform\n  // with the one below, which reflects the view state resolved from\n  // both user-supplied props and the underlying state\n  private _renderTransform: Transform;\n\n  // Internal states\n  private _internalUpdate: boolean = false;\n  private _inRender: boolean = false;\n  private _hoveredFeatures: MapGeoJSONFeature[] = null;\n  private _deferredEvents: {\n    move: boolean;\n    zoom: boolean;\n    pitch: boolean;\n    rotate: boolean;\n  } = {\n    move: false,\n    zoom: false,\n    pitch: false,\n    rotate: false\n  };\n\n  static savedMaps: Mapbox[] = [];\n\n  constructor(\n    MapClass: {new (options: any): MapInstance},\n    props: MapboxProps<StyleT, CallbacksT>,\n    container: HTMLDivElement\n  ) {\n    this._MapClass = MapClass;\n    this.props = props;\n    this._initialize(container);\n  }\n\n  get map(): MapT {\n    return this._map;\n  }\n\n  get transform(): Transform {\n    return this._renderTransform;\n  }\n\n  setProps(props: MapboxProps<StyleT, CallbacksT>) {\n    const oldProps = this.props;\n    this.props = props;\n\n    const settingsChanged = this._updateSettings(props, oldProps);\n    if (settingsChanged) {\n      this._createShadowTransform(this._map);\n    }\n    const sizeChanged = this._updateSize(props);\n    const viewStateChanged = this._updateViewState(props, true);\n    this._updateStyle(props, oldProps);\n    this._updateStyleComponents(props, oldProps);\n    this._updateHandlers(props, oldProps);\n\n    // If 1) view state has changed to match props and\n    //    2) the props change is not triggered by map events,\n    // it's driven by an external state change. Redraw immediately\n    if (settingsChanged || sizeChanged || (viewStateChanged && !this._map.isMoving())) {\n      this.redraw();\n    }\n  }\n\n  static reuse<StyleT extends MapStyle, CallbacksT extends Callbacks, MapT extends MapInstance>(\n    props: MapboxProps<StyleT, CallbacksT>,\n    container: HTMLDivElement\n  ): Mapbox<StyleT, CallbacksT, MapT> {\n    const that = Mapbox.savedMaps.pop() as Mapbox<StyleT, CallbacksT, MapT>;\n    if (!that) {\n      return null;\n    }\n\n    const map = that.map;\n    // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n    // intoto the new container from the props.\n    // Step 1: reparenting child nodes from old container to new container\n    const oldContainer = map.getContainer();\n    container.className = oldContainer.className;\n    while (oldContainer.childNodes.length > 0) {\n      container.appendChild(oldContainer.childNodes[0]);\n    }\n    // Step 2: replace the internal container with new container from the react component\n    // @ts-ignore\n    map._container = container;\n\n    // With maplibre-gl as mapLib, map uses ResizeObserver to observe when its container resizes.\n    // When reusing the saved map, we need to disconnect the observer and observe the new container.\n    // Step 3: telling the ResizeObserver to disconnect and observe the new container\n    // @ts-ignore\n    const resizeObserver = map._resizeObserver;\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n      resizeObserver.observe(container);\n    }\n\n    // Step 4: apply new props\n    that.setProps({...props, styleDiffing: false});\n    map.resize();\n    const {initialViewState} = props;\n    if (initialViewState) {\n      if (initialViewState.bounds) {\n        map.fitBounds(initialViewState.bounds, {...initialViewState.fitBoundsOptions, duration: 0});\n      } else {\n        that._updateViewState(initialViewState, false);\n      }\n    }\n\n    // Simulate load event\n    if (map.isStyleLoaded()) {\n      map.fire('load');\n    } else {\n      map.once('styledata', () => map.fire('load'));\n    }\n\n    // Force reload\n    // @ts-ignore\n    map._update();\n    return that;\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _initialize(container: HTMLDivElement) {\n    const {props} = this;\n    const {mapStyle = DEFAULT_STYLE} = props;\n    const mapOptions = {\n      ...props,\n      ...props.initialViewState,\n      accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n      container,\n      style: normalizeStyle(mapStyle)\n    };\n\n    const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n    Object.assign(mapOptions, {\n      center: [viewState.longitude || 0, viewState.latitude || 0],\n      zoom: viewState.zoom || 0,\n      pitch: viewState.pitch || 0,\n      bearing: viewState.bearing || 0\n    });\n\n    if (props.gl) {\n      // eslint-disable-next-line\n      const getContext = HTMLCanvasElement.prototype.getContext;\n      // Hijack canvas.getContext to return our own WebGLContext\n      // This will be called inside the mapboxgl.Map constructor\n      // @ts-expect-error\n      HTMLCanvasElement.prototype.getContext = () => {\n        // Unhijack immediately\n        HTMLCanvasElement.prototype.getContext = getContext;\n        return props.gl;\n      };\n    }\n\n    const map = new this._MapClass(mapOptions) as MapInstanceInternal<MapT>;\n    // Props that are not part of constructor options\n    if (viewState.padding) {\n      map.setPadding(viewState.padding);\n    }\n    if (props.cursor) {\n      map.getCanvas().style.cursor = props.cursor;\n    }\n    this._createShadowTransform(map);\n\n    // Hack\n    // Insert code into map's render cycle\n    const renderMap = map._render;\n    map._render = (arg: number) => {\n      this._inRender = true;\n      renderMap.call(map, arg);\n      this._inRender = false;\n    };\n    const runRenderTaskQueue = map._renderTaskQueue.run;\n    map._renderTaskQueue.run = (arg: number) => {\n      runRenderTaskQueue.call(map._renderTaskQueue, arg);\n      this._onBeforeRepaint();\n    };\n    map.on('render', () => this._onAfterRepaint());\n    // Insert code into map's event pipeline\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const fireEvent = map.fire;\n    map.fire = this._fireEvent.bind(this, fireEvent);\n\n    // add listeners\n    map.on('resize', () => {\n      this._renderTransform.resize(map.transform.width, map.transform.height);\n    });\n    map.on('styledata', () => {\n      this._updateStyleComponents(this.props, {});\n      // Projection can be set in stylesheet\n      syncProjection(map.transform, this._renderTransform);\n    });\n    map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n    for (const eventName in pointerEvents) {\n      map.on(eventName, this._onPointerEvent);\n    }\n    for (const eventName in cameraEvents) {\n      map.on(eventName, this._onCameraEvent);\n    }\n    for (const eventName in otherEvents) {\n      map.on(eventName, this._onEvent);\n    }\n    this._map = map;\n  }\n  /* eslint-enable complexity,max-statements */\n\n  recycle() {\n    // Clean up unnecessary elements before storing for reuse.\n    const container = this.map.getContainer();\n    const children = container.querySelector('[mapboxgl-children]');\n    children?.remove();\n\n    Mapbox.savedMaps.push(this);\n  }\n\n  destroy() {\n    this._map.remove();\n  }\n\n  // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n  // render cycle, which is managed by Mapbox's animation loop.\n  // This removes the synchronization issue caused by requestAnimationFrame.\n  redraw() {\n    const map = this._map as any;\n    // map._render will throw error if style does not exist\n    // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n    //   /src/ui/map.js#L1834\n    if (!this._inRender && map.style) {\n      // cancel the scheduled update\n      if (map._frame) {\n        map._frame.cancel();\n        map._frame = null;\n      }\n      // the order is important - render() may schedule another update\n      map._render();\n    }\n  }\n\n  _createShadowTransform(map: any) {\n    const renderTransform = cloneTransform(map.transform);\n    map.painter.transform = renderTransform;\n\n    this._renderTransform = renderTransform;\n  }\n\n  /* Trigger map resize if size is controlled\n     @param {object} nextProps\n     @returns {bool} true if size has changed\n   */\n  _updateSize(nextProps: MapboxProps<StyleT>): boolean {\n    // Check if size is controlled\n    const {viewState} = nextProps;\n    if (viewState) {\n      const map = this._map;\n      if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n        map.resize();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Adapted from map.jumpTo\n  /* Update camera to match props\n     @param {object} nextProps\n     @param {bool} triggerEvents - should fire camera events\n     @returns {bool} true if anything is changed\n   */\n  _updateViewState(nextProps: MapboxProps<StyleT>, triggerEvents: boolean): boolean {\n    if (this._internalUpdate) {\n      return false;\n    }\n    const map = this._map;\n\n    const tr = this._renderTransform;\n    // Take a snapshot of the transform before mutation\n    const {zoom, pitch, bearing} = tr;\n    const isMoving = map.isMoving();\n\n    if (isMoving) {\n      // All movement of the camera is done relative to the sea level\n      tr.cameraElevationReference = 'sea';\n    }\n    const changed = applyViewStateToTransform(tr, {\n      ...transformToViewState(map.transform),\n      ...nextProps\n    });\n    if (isMoving) {\n      // Reset camera reference\n      tr.cameraElevationReference = 'ground';\n    }\n\n    if (changed && triggerEvents) {\n      const deferredEvents = this._deferredEvents;\n      // Delay DOM control updates to the next render cycle\n      deferredEvents.move = true;\n      deferredEvents.zoom ||= zoom !== tr.zoom;\n      deferredEvents.rotate ||= bearing !== tr.bearing;\n      deferredEvents.pitch ||= pitch !== tr.pitch;\n    }\n\n    // Avoid manipulating the real transform when interaction/animation is ongoing\n    // as it would interfere with Mapbox's handlers\n    if (!isMoving) {\n      applyViewStateToTransform(map.transform, nextProps);\n    }\n\n    return changed;\n  }\n\n  /* Update camera constraints and projection settings to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateSettings(nextProps: MapboxProps<StyleT>, currProps: MapboxProps<StyleT>): boolean {\n    const map = this._map;\n    let changed = false;\n    for (const propName of settingNames) {\n      if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n        changed = true;\n        const setter = map[`set${propName[0].toUpperCase()}${propName.slice(1)}`];\n        setter?.call(map, nextProps[propName]);\n      }\n    }\n    return changed;\n  }\n\n  /* Update map style to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if style is changed\n   */\n  _updateStyle(nextProps: MapboxProps<StyleT>, currProps: MapboxProps<StyleT>): boolean {\n    if (nextProps.cursor !== currProps.cursor) {\n      this._map.getCanvas().style.cursor = nextProps.cursor || '';\n    }\n    if (nextProps.mapStyle !== currProps.mapStyle) {\n      const {mapStyle = DEFAULT_STYLE, styleDiffing = true} = nextProps;\n      const options: any = {\n        diff: styleDiffing\n      };\n      if ('localIdeographFontFamily' in nextProps) {\n        // @ts-ignore Mapbox specific prop\n        options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n      }\n      this._map.setStyle(normalizeStyle(mapStyle), options);\n      return true;\n    }\n    return false;\n  }\n\n  /* Update fog, light and terrain to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateStyleComponents(nextProps: MapboxProps<StyleT>, currProps: MapboxProps<StyleT>): boolean {\n    const map = this._map;\n    let changed = false;\n    if (map.isStyleLoaded()) {\n      if ('light' in nextProps && map.setLight && !deepEqual(nextProps.light, currProps.light)) {\n        changed = true;\n        map.setLight(nextProps.light);\n      }\n      if ('fog' in nextProps && map.setFog && !deepEqual(nextProps.fog, currProps.fog)) {\n        changed = true;\n        map.setFog(nextProps.fog);\n      }\n      if (\n        'terrain' in nextProps &&\n        map.setTerrain &&\n        !deepEqual(nextProps.terrain, currProps.terrain)\n      ) {\n        if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n          changed = true;\n          map.setTerrain(nextProps.terrain);\n        }\n      }\n    }\n    return changed;\n  }\n\n  /* Update interaction handlers to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateHandlers(nextProps: MapboxProps<StyleT>, currProps: MapboxProps<StyleT>): boolean {\n    const map = this._map;\n    let changed = false;\n    for (const propName of handlerNames) {\n      const newValue = nextProps[propName] ?? true;\n      const oldValue = currProps[propName] ?? true;\n      if (!deepEqual(newValue, oldValue)) {\n        changed = true;\n        if (newValue) {\n          map[propName].enable(newValue);\n        } else {\n          map[propName].disable();\n        }\n      }\n    }\n    return changed;\n  }\n\n  _onEvent = (e: MapEvent<MapT>) => {\n    // @ts-ignore\n    const cb = this.props[otherEvents[e.type]];\n    if (cb) {\n      cb(e);\n    } else if (e.type === 'error') {\n      console.error((e as ErrorEvent<MapT>).error); // eslint-disable-line\n    }\n  };\n\n  private _queryRenderedFeatures(point: Point) {\n    const map = this._map;\n    const tr = map.transform;\n    const {interactiveLayerIds = []} = this.props;\n    try {\n      map.transform = this._renderTransform;\n      return map.queryRenderedFeatures(point, {\n        layers: interactiveLayerIds.filter(map.getLayer.bind(map))\n      });\n    } catch {\n      // May fail if style is not loaded\n      return [];\n    } finally {\n      map.transform = tr;\n    }\n  }\n\n  _updateHover(e: MapMouseEvent<MapT>) {\n    const {props} = this;\n    const shouldTrackHoveredFeatures =\n      props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n\n    if (shouldTrackHoveredFeatures) {\n      const eventType = e.type;\n      const wasHovering = this._hoveredFeatures?.length > 0;\n      const features = this._queryRenderedFeatures(e.point);\n      const isHovering = features.length > 0;\n\n      if (!isHovering && wasHovering) {\n        e.type = 'mouseleave';\n        this._onPointerEvent(e);\n      }\n      this._hoveredFeatures = features;\n      if (isHovering && !wasHovering) {\n        e.type = 'mouseenter';\n        this._onPointerEvent(e);\n      }\n      e.type = eventType;\n    } else {\n      this._hoveredFeatures = null;\n    }\n  }\n\n  _onPointerEvent = (e: MapMouseEvent<MapT> | MapMouseEvent<MapT>) => {\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      this._updateHover(e);\n    }\n\n    // @ts-ignore\n    const cb = this.props[pointerEvents[e.type]];\n    if (cb) {\n      if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n        e.features = this._hoveredFeatures || this._queryRenderedFeatures(e.point);\n      }\n      cb(e);\n      delete e.features;\n    }\n  };\n\n  _onCameraEvent = (e: ViewStateChangeEvent<MapT>) => {\n    if (!this._internalUpdate) {\n      // @ts-ignore\n      const cb = this.props[cameraEvents[e.type]];\n      if (cb) {\n        cb(e);\n      }\n    }\n    if (e.type in this._deferredEvents) {\n      this._deferredEvents[e.type] = false;\n    }\n  };\n\n  _fireEvent(baseFire: Function, event: string | MapEvent<MapT>, properties?: object) {\n    const map = this._map;\n    const tr = map.transform;\n\n    const eventType = typeof event === 'string' ? event : event.type;\n    if (eventType === 'move') {\n      this._updateViewState(this.props, false);\n    }\n    if (eventType in cameraEvents) {\n      if (typeof event === 'object') {\n        (event as unknown as ViewStateChangeEvent<MapT>).viewState = transformToViewState(tr);\n      }\n      if (this._map.isMoving()) {\n        // Replace map.transform with ours during the callbacks\n        map.transform = this._renderTransform;\n        baseFire.call(map, event, properties);\n        map.transform = tr;\n\n        return map;\n      }\n    }\n    baseFire.call(map, event, properties);\n\n    return map;\n  }\n\n  // All camera manipulations are complete, ready to repaint\n  _onBeforeRepaint() {\n    const map = this._map;\n\n    // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n    this._internalUpdate = true;\n    for (const eventType in this._deferredEvents) {\n      if (this._deferredEvents[eventType]) {\n        map.fire(eventType);\n      }\n    }\n    this._internalUpdate = false;\n\n    const tr = this._map.transform;\n    // Make sure camera matches the current props\n    map.transform = this._renderTransform;\n\n    this._onAfterRepaint = () => {\n      // Mapbox transitions between non-mercator projection and mercator during render time\n      // Copy it back to the other\n      syncProjection(this._renderTransform, tr);\n      // Restores camera state before render/load events are fired\n      map.transform = tr;\n    };\n  }\n\n  _onAfterRepaint: () => void;\n}\n\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\nfunction getAccessTokenFromEnv(): string {\n  let accessToken = null;\n\n  /* global location, process */\n  if (typeof location !== 'undefined') {\n    const match = /access_token=([^&\\/]*)/.exec(location.search);\n    accessToken = match && match[1];\n  }\n\n  // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n  try {\n    accessToken = accessToken || process.env.MapboxAccessToken;\n  } catch {\n    // ignore\n  }\n\n  try {\n    accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  } catch {\n    // ignore\n  }\n\n  return accessToken;\n}\n","import type {\n  MapInstance,\n  MapInstanceInternal,\n  MapStyle,\n  Callbacks,\n  LngLatLike,\n  PointLike\n} from '../types';\nimport type Mapbox from './mapbox';\n\n/** These methods may break the react binding if called directly */\nconst skipMethods = [\n  'setMaxBounds',\n  'setMinZoom',\n  'setMaxZoom',\n  'setMinPitch',\n  'setMaxPitch',\n  'setRenderWorldCopies',\n  'setProjection',\n  'setStyle',\n  'addSource',\n  'removeSource',\n  'addLayer',\n  'removeLayer',\n  'setLayerZoomRange',\n  'setFilter',\n  'setPaintProperty',\n  'setLayoutProperty',\n  'setLight',\n  'setTerrain',\n  'setFog',\n  'remove'\n] as const;\n\nexport type MapRef<MapT extends MapInstance> = {\n  getMap(): MapT;\n} & Omit<MapT, typeof skipMethods[number]>;\n\nexport default function createRef<\n  StyleT extends MapStyle,\n  CallbacksT extends Callbacks,\n  MapT extends MapInstance\n>(mapInstance: Mapbox<StyleT, CallbacksT, MapT>): MapRef<MapT> | null {\n  if (!mapInstance) {\n    return null;\n  }\n\n  const map = mapInstance.map as MapInstanceInternal<MapT>;\n  const result: any = {\n    getMap: () => map,\n\n    // Overwrite getters to use our shadow transform\n    getCenter: () => mapInstance.transform.center,\n    getZoom: () => mapInstance.transform.zoom,\n    getBearing: () => mapInstance.transform.bearing,\n    getPitch: () => mapInstance.transform.pitch,\n    getPadding: () => mapInstance.transform.padding,\n    getBounds: () => mapInstance.transform.getBounds(),\n    project: (lnglat: LngLatLike) => {\n      const tr = map.transform;\n      map.transform = mapInstance.transform;\n      const result = map.project(lnglat);\n      map.transform = tr;\n      return result;\n    },\n    unproject: (point: PointLike) => {\n      const tr = map.transform;\n      map.transform = mapInstance.transform;\n      const result = map.unproject(point);\n      map.transform = tr;\n      return result;\n    },\n    // options diverge between mapbox and maplibre\n    queryTerrainElevation: (lnglat: LngLatLike, options?: any) => {\n      const tr = map.transform;\n      map.transform = mapInstance.transform;\n      const result = map.queryTerrainElevation(lnglat, options);\n      map.transform = tr;\n      return result;\n    },\n    queryRenderedFeatures: (geometry?: any, options?: any) => {\n      const tr = map.transform;\n      map.transform = mapInstance.transform;\n      const result = map.queryRenderedFeatures(geometry, options);\n      map.transform = tr;\n      return result;\n    }\n  };\n\n  for (const key of getMethodNames(map)) {\n    // @ts-expect-error\n    if (!(key in result) && !skipMethods.includes(key)) {\n      result[key] = map[key].bind(map);\n    }\n  }\n\n  return result;\n}\n\nfunction getMethodNames(obj: Object) {\n  const result = new Set<string>();\n\n  let proto = obj;\n  while (proto) {\n    for (const key of Object.getOwnPropertyNames(proto)) {\n      if (\n        key[0] !== '_' &&\n        typeof obj[key] === 'function' &&\n        key !== 'fire' &&\n        key !== 'setEventedParent'\n      ) {\n        result.add(key);\n      }\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n  return Array.from(result);\n}\n","// From https://github.com/streamich/react-use/blob/master/src/useIsomorphicLayoutEffect.ts\n// useLayoutEffect but does not trigger warning in server-side rendering\nimport {useEffect, useLayoutEffect} from 'react';\n\nconst useIsomorphicLayoutEffect = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\nexport default useIsomorphicLayoutEffect;\n","export type GlobalSettings = {\n  /** The map's default API URL for requesting tiles, styles, sprites, and glyphs. */\n  baseApiUrl?: string;\n  /** The maximum number of images (raster tiles, sprites, icons) to load in parallel.\n   * @default 16\n   */\n  maxParallelImageRequests?: number;\n  /** The map's RTL text plugin. Necessary for supporting the Arabic and Hebrew languages, which are written right-to-left.  */\n  RTLTextPlugin?: string | false;\n  /** Provides an interface for external module bundlers such as Webpack or Rollup to package mapbox-gl's WebWorker into a separate class and integrate it with the library.\nTakes precedence over `workerUrl`. */\n  workerClass?: any;\n  /** The number of web workers instantiated on a page with mapbox-gl maps.\n   * @default 2\n   */\n  workerCount?: number;\n  /** Provides an interface for loading mapbox-gl's WebWorker bundle from a self-hosted URL.\n   * This is useful if your site needs to operate in a strict CSP (Content Security Policy) environment\n   * wherein you are not allowed to load JavaScript code from a Blob URL, which is default behavior. */\n  workerUrl?: string;\n};\n\nconst globalSettings = [\n  'baseApiUrl',\n  'maxParallelImageRequests',\n  'workerClass',\n  'workerCount',\n  'workerUrl'\n] as const;\n\nexport default function setGlobals(mapLib: any, props: GlobalSettings) {\n  for (const key of globalSettings) {\n    if (key in props) {\n      mapLib[key] = props[key];\n    }\n  }\n\n  const {\n    RTLTextPlugin = 'https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js'\n  } = props;\n  if (\n    RTLTextPlugin &&\n    mapLib.getRTLTextPluginStatus &&\n    mapLib.getRTLTextPluginStatus() === 'unavailable'\n  ) {\n    mapLib.setRTLTextPlugin(\n      RTLTextPlugin,\n      (error?: Error) => {\n        if (error) {\n          // eslint-disable-next-line\n          console.error(error);\n        }\n      },\n      true\n    );\n  }\n}\n","import * as React from 'react';\nimport {useState, useRef, useEffect, useContext, useMemo, useImperativeHandle} from 'react';\n\nimport {MountedMapsContext} from './use-map';\nimport Mapbox, {MapboxProps} from '../mapbox/mapbox';\nimport createRef, {MapRef} from '../mapbox/create-ref';\n\nimport type {CSSProperties} from 'react';\nimport useIsomorphicLayoutEffect from '../utils/use-isomorphic-layout-effect';\nimport setGlobals, {GlobalSettings} from '../utils/set-globals';\nimport type {MapLib, MapInstance, MapStyle, Callbacks} from '../types';\n\nexport type MapContextValue<MapT extends MapInstance = MapInstance> = {\n  mapLib: MapLib<MapT>;\n  map: MapRef<MapT>;\n};\n\nexport const MapContext = React.createContext<MapContextValue>(null);\n\ntype MapInitOptions<MapOptions> = Omit<\n  MapOptions,\n  'style' | 'container' | 'bounds' | 'fitBoundsOptions' | 'center'\n>;\n\nexport type MapProps<\n  MapOptions,\n  StyleT extends MapStyle,\n  CallbacksT extends Callbacks,\n  MapT extends MapInstance\n> = MapInitOptions<MapOptions> &\n  MapboxProps<StyleT, CallbacksT> &\n  GlobalSettings & {\n    mapLib?: MapLib<MapT> | Promise<MapLib<MapT>>;\n    reuseMaps?: boolean;\n    /** Map container id */\n    id?: string;\n    /** Map container CSS style */\n    style?: CSSProperties;\n    children?: any;\n  };\n\nexport default function Map<\n  MapOptions,\n  StyleT extends MapStyle,\n  CallbacksT extends Callbacks,\n  MapT extends MapInstance\n>(\n  props: MapProps<MapOptions, StyleT, CallbacksT, MapT>,\n  ref: React.Ref<MapRef<MapT>>,\n  defaultLib: MapLib<MapT> | Promise<MapLib<MapT>>\n) {\n  const mountedMapsContext = useContext(MountedMapsContext);\n  const [mapInstance, setMapInstance] = useState<Mapbox<StyleT, CallbacksT, MapT>>(null);\n  const containerRef = useRef();\n\n  const {current: contextValue} = useRef<MapContextValue<MapT>>({mapLib: null, map: null});\n\n  useEffect(() => {\n    const mapLib = props.mapLib;\n    let isMounted = true;\n    let mapbox: Mapbox<StyleT, CallbacksT, MapT>;\n\n    Promise.resolve(mapLib || defaultLib)\n      .then((module: MapLib<MapT> | {default: MapLib<MapT>}) => {\n        if (!isMounted) {\n          return;\n        }\n        if (!module) {\n          throw new Error('Invalid mapLib');\n        }\n        const mapboxgl = 'Map' in module ? module : module.default;\n        if (!mapboxgl.Map) {\n          throw new Error('Invalid mapLib');\n        }\n\n        // workerUrl & workerClass may change the result of supported()\n        // https://github.com/visgl/react-map-gl/discussions/2027\n        setGlobals(mapboxgl, props);\n        if (!mapboxgl.supported || mapboxgl.supported(props)) {\n          if (props.reuseMaps) {\n            mapbox = Mapbox.reuse(props, containerRef.current);\n          }\n          if (!mapbox) {\n            mapbox = new Mapbox(mapboxgl.Map, props, containerRef.current);\n          }\n          contextValue.map = createRef(mapbox);\n          contextValue.mapLib = mapboxgl;\n\n          setMapInstance(mapbox);\n          mountedMapsContext?.onMapMount(contextValue.map, props.id);\n        } else {\n          throw new Error('Map is not supported by this browser');\n        }\n      })\n      .catch(error => {\n        const {onError} = props;\n        if (onError) {\n          onError({\n            type: 'error',\n            target: null,\n            originalEvent: null,\n            error\n          });\n        } else {\n          console.error(error); // eslint-disable-line\n        }\n      });\n\n    return () => {\n      isMounted = false;\n      if (mapbox) {\n        mountedMapsContext?.onMapUnmount(props.id);\n        if (props.reuseMaps) {\n          mapbox.recycle();\n        } else {\n          mapbox.destroy();\n        }\n      }\n    };\n  }, []);\n\n  useIsomorphicLayoutEffect(() => {\n    if (mapInstance) {\n      mapInstance.setProps(props);\n    }\n  });\n\n  useImperativeHandle(ref, () => contextValue.map, [mapInstance]);\n\n  const style: CSSProperties = useMemo(\n    () => ({\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      ...props.style\n    }),\n    [props.style]\n  );\n\n  const CHILD_CONTAINER_STYLE = {\n    height: '100%'\n  };\n\n  return (\n    <div id={props.id} ref={containerRef} style={style}>\n      {mapInstance && (\n        <MapContext.Provider value={contextValue}>\n          <div mapboxgl-children=\"\" style={CHILD_CONTAINER_STYLE}>\n            {props.children}\n          </div>\n        </MapContext.Provider>\n      )}\n    </div>\n  );\n}\n","import * as React from 'react';\n// This is a simplified version of\n// https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSPropertyOperations.js#L62\nconst unitlessNumber = /box|flex|grid|column|lineHeight|fontWeight|opacity|order|tabSize|zIndex/;\n\nexport function applyReactStyle(element: HTMLElement, styles: React.CSSProperties) {\n  if (!element || !styles) {\n    return;\n  }\n  const style = element.style;\n\n  for (const key in styles) {\n    const value = styles[key];\n    if (Number.isFinite(value) && !unitlessNumber.test(key)) {\n      style[key] = `${value}px`;\n    } else {\n      style[key] = value;\n    }\n  }\n}\n","/* global document */\nimport * as React from 'react';\nimport {createPortal} from 'react-dom';\nimport {useImperativeHandle, useEffect, useMemo, useRef, useContext, forwardRef, memo} from 'react';\nimport {applyReactStyle} from '../utils/apply-react-style';\n\nimport type {MarkerEvent, MarkerDragEvent, PointLike, MarkerInstance} from '../types';\n\nimport {MapContext} from './map';\nimport {arePointsEqual} from '../utils/deep-equal';\n\nexport type MarkerProps<OptionsT, MarkerT extends MarkerInstance> = OptionsT & {\n  /** Longitude of the anchor location */\n  longitude: number;\n  /** Latitude of the anchor location */\n  latitude: number;\n\n  // These types will be further constraint by OptionsT\n  draggable?: boolean;\n  offset?: PointLike;\n  pitchAlignment?: string;\n  rotation?: number;\n  rotationAlignment?: string;\n  popup?: any;\n\n  /** CSS style override, applied to the control's container */\n  style?: React.CSSProperties;\n  onClick?: (e: MarkerEvent<MarkerT, MouseEvent>) => void;\n  onDragStart?: (e: MarkerDragEvent<MarkerT>) => void;\n  onDrag?: (e: MarkerDragEvent<MarkerT>) => void;\n  onDragEnd?: (e: MarkerDragEvent<MarkerT>) => void;\n  children?: React.ReactNode;\n};\n\n/* eslint-disable complexity,max-statements */\nfunction Marker<MarkerOptions, MarkerT extends MarkerInstance>(\n  props: MarkerProps<MarkerOptions, MarkerT>,\n  ref: React.Ref<MarkerT>\n) {\n  const {map, mapLib} = useContext(MapContext);\n  const thisRef = useRef({props});\n  thisRef.current.props = props;\n\n  const marker: MarkerT = useMemo(() => {\n    let hasChildren = false;\n    React.Children.forEach(props.children, el => {\n      if (el) {\n        hasChildren = true;\n      }\n    });\n    const options = {\n      ...props,\n      element: hasChildren ? document.createElement('div') : null\n    };\n\n    const mk = new mapLib.Marker(options) as MarkerT;\n    mk.setLngLat([props.longitude, props.latitude]);\n\n    mk.getElement().addEventListener('click', (e: MouseEvent) => {\n      thisRef.current.props.onClick?.({\n        type: 'click',\n        target: mk,\n        originalEvent: e\n      });\n    });\n\n    mk.on('dragstart', e => {\n      const evt = e as MarkerDragEvent<MarkerT>;\n      evt.lngLat = marker.getLngLat();\n      thisRef.current.props.onDragStart?.(evt);\n    });\n    mk.on('drag', e => {\n      const evt = e as MarkerDragEvent<MarkerT>;\n      evt.lngLat = marker.getLngLat();\n      thisRef.current.props.onDrag?.(evt);\n    });\n    mk.on('dragend', e => {\n      const evt = e as MarkerDragEvent<MarkerT>;\n      evt.lngLat = marker.getLngLat();\n      thisRef.current.props.onDragEnd?.(evt);\n    });\n\n    return mk;\n  }, []);\n\n  useEffect(() => {\n    marker.addTo(map.getMap());\n\n    return () => {\n      marker.remove();\n    };\n  }, []);\n\n  const {\n    longitude,\n    latitude,\n    offset,\n    style,\n    draggable = false,\n    popup = null,\n    rotation = 0,\n    rotationAlignment = 'auto',\n    pitchAlignment = 'auto'\n  } = props;\n\n  useEffect(() => {\n    applyReactStyle(marker.getElement(), style);\n  }, [style]);\n\n  useImperativeHandle(ref, () => marker, []);\n\n  if (marker.getLngLat().lng !== longitude || marker.getLngLat().lat !== latitude) {\n    marker.setLngLat([longitude, latitude]);\n  }\n  if (offset && !arePointsEqual(marker.getOffset(), offset)) {\n    marker.setOffset(offset);\n  }\n  if (marker.isDraggable() !== draggable) {\n    marker.setDraggable(draggable);\n  }\n  if (marker.getRotation() !== rotation) {\n    marker.setRotation(rotation);\n  }\n  if (marker.getRotationAlignment() !== rotationAlignment) {\n    marker.setRotationAlignment(rotationAlignment);\n  }\n  if (marker.getPitchAlignment() !== pitchAlignment) {\n    marker.setPitchAlignment(pitchAlignment);\n  }\n  if (marker.getPopup() !== popup) {\n    marker.setPopup(popup);\n  }\n\n  return createPortal(props.children, marker.getElement());\n}\n\nexport default memo(forwardRef(Marker));\n","/* global document */\nimport * as React from 'react';\nimport {createPortal} from 'react-dom';\nimport {useImperativeHandle, useEffect, useMemo, useRef, useContext, forwardRef, memo} from 'react';\nimport {applyReactStyle} from '../utils/apply-react-style';\n\nimport type {PopupEvent, PopupInstance} from '../types';\n\nimport {MapContext} from './map';\nimport {deepEqual} from '../utils/deep-equal';\n\nexport type PopupProps<OptionsT, PopupT extends PopupInstance> = OptionsT & {\n  /** Longitude of the anchor location */\n  longitude: number;\n  /** Latitude of the anchor location */\n  latitude: number;\n\n  // These types will be further constraint by OptionsT\n  anchor?: string;\n  offset?: any;\n  className?: string;\n  maxWidth?: string;\n\n  /** CSS style override, applied to the control's container */\n  style?: React.CSSProperties;\n\n  onOpen?: (e: PopupEvent<PopupT>) => void;\n  onClose?: (e: PopupEvent<PopupT>) => void;\n  children?: React.ReactNode;\n};\n\n// Adapted from https://github.com/mapbox/mapbox-gl-js/blob/v1.13.0/src/ui/popup.js\nfunction getClassList(className: string) {\n  return new Set(className ? className.trim().split(/\\s+/) : []);\n}\n\n/* eslint-disable complexity,max-statements */\nfunction Popup<PopupOptions, PopupT extends PopupInstance>(\n  props: PopupProps<PopupOptions, PopupT>,\n  ref: React.Ref<PopupT>\n) {\n  const {map, mapLib} = useContext(MapContext);\n  const container = useMemo(() => {\n    return document.createElement('div');\n  }, []);\n  const thisRef = useRef({props});\n  thisRef.current.props = props;\n\n  const popup: PopupT = useMemo(() => {\n    const options = {...props};\n    const pp = new mapLib.Popup(options) as PopupT;\n    pp.setLngLat([props.longitude, props.latitude]);\n    pp.once('open', e => {\n      thisRef.current.props.onOpen?.(e as PopupEvent<PopupT>);\n    });\n    return pp;\n  }, []);\n\n  useEffect(() => {\n    const onClose = e => {\n      thisRef.current.props.onClose?.(e as PopupEvent<PopupT>);\n    };\n    popup.on('close', onClose);\n    popup.setDOMContent(container).addTo(map.getMap());\n\n    return () => {\n      // https://github.com/visgl/react-map-gl/issues/1825\n      // onClose should not be fired if the popup is removed by unmounting\n      // When using React strict mode, the component is mounted twice.\n      // Firing the onClose callback here would be a false signal to remove the component.\n      popup.off('close', onClose);\n      if (popup.isOpen()) {\n        popup.remove();\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    applyReactStyle(popup.getElement(), props.style);\n  }, [props.style]);\n\n  useImperativeHandle(ref, () => popup, []);\n\n  if (popup.isOpen()) {\n    if (popup.getLngLat().lng !== props.longitude || popup.getLngLat().lat !== props.latitude) {\n      popup.setLngLat([props.longitude, props.latitude]);\n    }\n    if (props.offset && !deepEqual(popup.options.offset, props.offset)) {\n      popup.setOffset(props.offset);\n    }\n    if (popup.options.anchor !== props.anchor || popup.options.maxWidth !== props.maxWidth) {\n      popup.options.anchor = props.anchor;\n      popup.setMaxWidth(props.maxWidth);\n    }\n    if (popup.options.className !== props.className) {\n      const prevClassList = getClassList(popup.options.className);\n      const nextClassList = getClassList(props.className);\n\n      for (const c of prevClassList) {\n        if (!nextClassList.has(c)) {\n          popup.removeClassName(c);\n        }\n      }\n      for (const c of nextClassList) {\n        if (!prevClassList.has(c)) {\n          popup.addClassName(c);\n        }\n      }\n      popup.options.className = props.className;\n    }\n  }\n\n  return createPortal(props.children, container);\n}\n\nexport default memo(forwardRef(Popup));\n","import {useContext, useMemo, useEffect} from 'react';\nimport type {IControl, ControlPosition} from '../types';\nimport {MapContext} from './map';\nimport type {MapContextValue} from './map';\n\ntype ControlOptions = {\n  position?: ControlPosition;\n};\n\nfunction useControl<T extends IControl>(\n  onCreate: (context: MapContextValue) => T,\n  opts?: ControlOptions\n): T;\n\nfunction useControl<T extends IControl>(\n  onCreate: (context: MapContextValue) => T,\n  onRemove: (context: MapContextValue) => void,\n  opts?: ControlOptions\n): T;\n\nfunction useControl<T extends IControl>(\n  onCreate: (context: MapContextValue) => T,\n  onAdd: (context: MapContextValue) => void,\n  onRemove: (context: MapContextValue) => void,\n  opts?: ControlOptions\n): T;\n\nfunction useControl<T extends IControl>(\n  onCreate: (context: MapContextValue) => T,\n  arg1?: ((context: MapContextValue) => void) | ControlOptions,\n  arg2?: ((context: MapContextValue) => void) | ControlOptions,\n  arg3?: ControlOptions\n): T {\n  const context = useContext(MapContext);\n  const ctrl = useMemo(() => onCreate(context), []);\n\n  useEffect(() => {\n    const opts = (arg3 || arg2 || arg1) as ControlOptions;\n    const onAdd = typeof arg1 === 'function' && typeof arg2 === 'function' ? arg1 : null;\n    const onRemove = typeof arg2 === 'function' ? arg2 : typeof arg1 === 'function' ? arg1 : null;\n\n    const {map} = context;\n    if (!map.hasControl(ctrl)) {\n      map.addControl(ctrl, opts?.position);\n      if (onAdd) {\n        onAdd(context);\n      }\n    }\n\n    return () => {\n      if (onRemove) {\n        onRemove(context);\n      }\n      // Map might have been removed (parent effects are destroyed before child ones)\n      if (map.hasControl(ctrl)) {\n        map.removeControl(ctrl);\n      }\n    };\n  }, []);\n\n  return ctrl;\n}\n\nexport default useControl;\n","import * as React from 'react';\nimport {useEffect, memo} from 'react';\nimport {applyReactStyle} from '../utils/apply-react-style';\nimport useControl from './use-control';\n\nimport type {ControlPosition, AttributionControlInstance} from '../types';\n\nexport type AttributionControlProps<OptionsT> = OptionsT & {\n  /** Placement of the control relative to the map. */\n  position?: ControlPosition;\n  /** CSS style override, applied to the control's container */\n  style?: React.CSSProperties;\n};\n\nfunction AttributionControl<AttributionControlOptions, ControlT extends AttributionControlInstance>(\n  props: AttributionControlProps<AttributionControlOptions>\n): null {\n  const ctrl = useControl<ControlT>(\n    ({mapLib}) => new mapLib.AttributionControl(props) as ControlT,\n    {\n      position: props.position\n    }\n  );\n\n  useEffect(() => {\n    applyReactStyle(ctrl._container, props.style);\n  }, [props.style]);\n\n  return null;\n}\n\nexport default memo(AttributionControl);\n","/* global document */\nimport * as React from 'react';\nimport {useEffect, memo} from 'react';\nimport {applyReactStyle} from '../utils/apply-react-style';\nimport useControl from './use-control';\n\nimport type {ControlPosition, FullscreenControlInstance} from '../types';\n\nexport type FullscreenControlProps<OptionsT> = Omit<OptionsT, 'container'> & {\n  /** Id of the DOM element which should be made full screen. By default, the map container\n   * element will be made full screen. */\n  containerId?: string;\n  /** Placement of the control relative to the map. */\n  position?: ControlPosition;\n  /** CSS style override, applied to the control's container */\n  style?: React.CSSProperties;\n};\n\nfunction FullscreenControl<FullscreenControlOptions, ControlT extends FullscreenControlInstance>(\n  props: FullscreenControlProps<FullscreenControlOptions>\n): null {\n  const ctrl = useControl<ControlT>(\n    ({mapLib}) =>\n      new mapLib.FullscreenControl({\n        container: props.containerId && document.getElementById(props.containerId)\n      }) as ControlT,\n    {position: props.position}\n  );\n\n  useEffect(() => {\n    applyReactStyle(ctrl._controlContainer, props.style);\n  }, [props.style]);\n\n  return null;\n}\n\nexport default memo(FullscreenControl);\n","import * as React from 'react';\nimport {useImperativeHandle, useRef, useEffect, forwardRef, memo} from 'react';\nimport {applyReactStyle} from '../utils/apply-react-style';\nimport useControl from './use-control';\n\nimport type {\n  ControlPosition,\n  GeolocateControlInstance,\n  GeolocateEvent,\n  GeolocateResultEvent,\n  GeolocateErrorEvent\n} from '../types';\n\nexport type GeolocateControlProps<\n  OptionsT,\n  ControlT extends GeolocateControlInstance\n> = OptionsT & {\n  /** Placement of the control relative to the map. */\n  position?: ControlPosition;\n  /** CSS style override, applied to the control's container */\n  style?: React.CSSProperties;\n\n  /** Called on each Geolocation API position update that returned as success. */\n  onGeolocate?: (e: GeolocateResultEvent<ControlT>) => void;\n  /** Called on each Geolocation API position update that returned as an error. */\n  onError?: (e: GeolocateErrorEvent<ControlT>) => void;\n  /** Called on each Geolocation API position update that returned as success but user position\n   * is out of map `maxBounds`. */\n  onOutOfMaxBounds?: (e: GeolocateResultEvent<ControlT>) => void;\n  /** Called when the GeolocateControl changes to the active lock state. */\n  onTrackUserLocationStart?: (e: GeolocateEvent<ControlT>) => void;\n  /** Called when the GeolocateControl changes to the background state. */\n  onTrackUserLocationEnd?: (e: GeolocateEvent<ControlT>) => void;\n};\n\nfunction GeolocateControl<GeolocateControlOptions, ControlT extends GeolocateControlInstance>(\n  props: GeolocateControlProps<GeolocateControlOptions, ControlT>,\n  ref: React.Ref<ControlT>\n) {\n  const thisRef = useRef({props});\n\n  const ctrl = useControl<ControlT>(\n    ({mapLib}) => {\n      const gc = new mapLib.GeolocateControl(props) as ControlT;\n\n      // Hack: fix GeolocateControl reuse\n      // When using React strict mode, the component is mounted twice.\n      // GeolocateControl's UI creation is asynchronous. Removing and adding it back causes the UI to be initialized twice.\n      // @ts-expect-error private method\n      const setupUI = gc._setupUI;\n      // @ts-expect-error private method\n      gc._setupUI = args => {\n        if (!gc._container.hasChildNodes()) {\n          setupUI(args);\n        }\n      };\n\n      gc.on('geolocate', e => {\n        thisRef.current.props.onGeolocate?.(e as GeolocateResultEvent<ControlT>);\n      });\n      gc.on('error', e => {\n        thisRef.current.props.onError?.(e as GeolocateErrorEvent<ControlT>);\n      });\n      gc.on('outofmaxbounds', e => {\n        thisRef.current.props.onOutOfMaxBounds?.(e as GeolocateResultEvent<ControlT>);\n      });\n      gc.on('trackuserlocationstart', e => {\n        thisRef.current.props.onTrackUserLocationStart?.(e as GeolocateEvent<ControlT>);\n      });\n      gc.on('trackuserlocationend', e => {\n        thisRef.current.props.onTrackUserLocationEnd?.(e as GeolocateEvent<ControlT>);\n      });\n\n      return gc;\n    },\n    {position: props.position}\n  );\n\n  thisRef.current.props = props;\n\n  useImperativeHandle(ref, () => ctrl, []);\n\n  useEffect(() => {\n    applyReactStyle(ctrl._container, props.style);\n  }, [props.style]);\n\n  return null;\n}\n\nexport default memo(forwardRef(GeolocateControl));\n","import * as React from 'react';\nimport {useEffect, memo} from 'react';\nimport {applyReactStyle} from '../utils/apply-react-style';\nimport useControl from './use-control';\n\nimport type {ControlPosition, NavigationControlInstance} from '../types';\n\nexport type NavigationControlProps<OptionsT> = OptionsT & {\n  /** Placement of the control relative to the map. */\n  position?: ControlPosition;\n  /** CSS style override, applied to the control's container */\n  style?: React.CSSProperties;\n};\n\nfunction NavigationControl<NavigationControlOptions, ControlT extends NavigationControlInstance>(\n  props: NavigationControlProps<NavigationControlOptions>\n): null {\n  const ctrl = useControl<ControlT>(({mapLib}) => new mapLib.NavigationControl(props) as ControlT, {\n    position: props.position\n  });\n\n  useEffect(() => {\n    applyReactStyle(ctrl._container, props.style);\n  }, [props.style]);\n\n  return null;\n}\n\nexport default memo(NavigationControl);\n","import * as React from 'react';\nimport {useEffect, useRef, memo} from 'react';\nimport {applyReactStyle} from '../utils/apply-react-style';\nimport useControl from './use-control';\n\nimport type {ControlPosition, ScaleControlInstance} from '../types';\n\nexport type ScaleControlProps<OptionsT> = OptionsT & {\n  // These props will be further constraint by OptionsT\n  unit?: string;\n  maxWidth?: number;\n\n  /** Placement of the control relative to the map. */\n  position?: ControlPosition;\n  /** CSS style override, applied to the control's container */\n  style?: React.CSSProperties;\n};\n\nfunction ScaleControl<ScaleControlOptions, ControlT extends ScaleControlInstance>(\n  props: ScaleControlProps<ScaleControlOptions>\n): null {\n  const ctrl = useControl<ControlT>(({mapLib}) => new mapLib.ScaleControl(props) as ControlT, {\n    position: props.position\n  });\n  const propsRef = useRef<ScaleControlProps<ScaleControlOptions>>(props);\n\n  const prevProps = propsRef.current;\n  propsRef.current = props;\n\n  const {style} = props;\n\n  if (props.maxWidth !== undefined && props.maxWidth !== prevProps.maxWidth) {\n    ctrl.options.maxWidth = props.maxWidth;\n  }\n  if (props.unit !== undefined && props.unit !== prevProps.unit) {\n    ctrl.setUnit(props.unit);\n  }\n\n  useEffect(() => {\n    applyReactStyle(ctrl._container, style);\n  }, [style]);\n\n  return null;\n}\n\nexport default memo(ScaleControl);\n","export default function assert(condition: any, message: string) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n","import {useContext, useEffect, useMemo, useState, useRef} from 'react';\nimport {MapContext} from './map';\nimport assert from '../utils/assert';\nimport {deepEqual} from '../utils/deep-equal';\n\nimport type {MapInstance, CustomLayerInterface, ILayer} from '../types';\n\n// Omiting property from a union type, see\n// https://github.com/microsoft/TypeScript/issues/39556#issuecomment-656925230\ntype OptionalId<T> = T extends {id: string} ? Omit<T, 'id'> & {id?: string} : T;\ntype OptionalSource<T> = T extends {source: string} ? Omit<T, 'source'> & {source?: string} : T;\n\nexport type LayerProps<LayerT> = OptionalSource<OptionalId<LayerT>> & {\n  /** If set, the layer will be inserted before the specified layer */\n  beforeId?: string;\n};\n\n/* eslint-disable complexity, max-statements */\nfunction updateLayer<LayerT extends ILayer>(\n  map: MapInstance,\n  id: string,\n  props: LayerProps<LayerT>,\n  prevProps: LayerProps<LayerT>\n) {\n  assert(props.id === prevProps.id, 'layer id changed');\n  assert(props.type === prevProps.type, 'layer type changed');\n\n  if (props.type === 'custom' || prevProps.type === 'custom') {\n    return;\n  }\n\n  const {layout = {}, paint = {}, filter, minzoom, maxzoom, beforeId} = props;\n\n  if (beforeId !== prevProps.beforeId) {\n    map.moveLayer(id, beforeId);\n  }\n  if (layout !== prevProps.layout) {\n    const prevLayout = prevProps.layout || {};\n    for (const key in layout) {\n      if (!deepEqual(layout[key], prevLayout[key])) {\n        map.setLayoutProperty(id, key, layout[key]);\n      }\n    }\n    for (const key in prevLayout) {\n      if (!layout.hasOwnProperty(key)) {\n        map.setLayoutProperty(id, key, undefined);\n      }\n    }\n  }\n  if (paint !== prevProps.paint) {\n    const prevPaint = prevProps.paint || {};\n    for (const key in paint) {\n      if (!deepEqual(paint[key], prevPaint[key])) {\n        map.setPaintProperty(id, key, paint[key]);\n      }\n    }\n    for (const key in prevPaint) {\n      if (!paint.hasOwnProperty(key)) {\n        map.setPaintProperty(id, key, undefined);\n      }\n    }\n  }\n\n  if (!deepEqual(filter, prevProps.filter)) {\n    map.setFilter(id, filter);\n  }\n  if (minzoom !== prevProps.minzoom || maxzoom !== prevProps.maxzoom) {\n    map.setLayerZoomRange(id, minzoom, maxzoom);\n  }\n}\n\nfunction createLayer<LayerT extends ILayer>(\n  map: MapInstance,\n  id: string,\n  props: LayerProps<LayerT>\n) {\n  // @ts-ignore\n  if (map.style && map.style._loaded && (!('source' in props) || map.getSource(props.source))) {\n    const options: LayerProps<LayerT> = {...props, id};\n    delete options.beforeId;\n\n    // @ts-ignore\n    map.addLayer(options, props.beforeId);\n  }\n}\n\n/* eslint-enable complexity, max-statements */\n\nlet layerCounter = 0;\n\nfunction Layer<LayerT extends ILayer>(props: LayerProps<LayerT | CustomLayerInterface>) {\n  const map = useContext(MapContext).map.getMap();\n  const propsRef = useRef(props);\n  const [, setStyleLoaded] = useState(0);\n\n  const id = useMemo(() => props.id || `jsx-layer-${layerCounter++}`, []);\n\n  useEffect(() => {\n    if (map) {\n      const forceUpdate = () => setStyleLoaded(version => version + 1);\n      map.on('styledata', forceUpdate);\n      forceUpdate();\n\n      return () => {\n        map.off('styledata', forceUpdate);\n        // @ts-ignore\n        if (map.style && map.style._loaded && map.getLayer(id)) {\n          map.removeLayer(id);\n        }\n      };\n    }\n    return undefined;\n  }, [map]);\n\n  // @ts-ignore\n  const layer = map && map.style && map.getLayer(id);\n  if (layer) {\n    try {\n      updateLayer(map, id, props, propsRef.current);\n    } catch (error) {\n      console.warn(error); // eslint-disable-line\n    }\n  } else {\n    createLayer(map, id, props);\n  }\n\n  // Store last rendered props\n  propsRef.current = props;\n\n  return null;\n}\n\nexport default Layer;\n","import * as React from 'react';\nimport {useContext, useEffect, useMemo, useState, useRef} from 'react';\nimport {cloneElement} from 'react';\nimport {MapContext} from './map';\nimport assert from '../utils/assert';\nimport {deepEqual} from '../utils/deep-equal';\n\nimport type {\n  MapInstance,\n  ISource,\n  CustomSource,\n  GeoJSONSourceImplementation,\n  ImageSourceImplemtation,\n  AnySourceImplementation\n} from '../types';\nimport type {GeoJSONSourceRaw, ImageSourceRaw, VectorSourceRaw} from '../types/style-spec-maplibre';\n\nexport type SourceProps<SourceT> = (SourceT | CustomSource) & {\n  id?: string;\n  children?: any;\n};\n\nlet sourceCounter = 0;\n\nfunction createSource<SourceT extends ISource>(\n  map: MapInstance,\n  id: string,\n  props: SourceProps<SourceT>\n) {\n  // @ts-ignore\n  if (map.style && map.style._loaded) {\n    const options = {...props};\n    delete options.id;\n    delete options.children;\n    // @ts-ignore\n    map.addSource(id, options);\n    return map.getSource(id);\n  }\n  return null;\n}\n\n/* eslint-disable complexity */\nfunction updateSource<SourceT extends ISource>(\n  source: AnySourceImplementation,\n  props: SourceProps<SourceT>,\n  prevProps: SourceProps<SourceT>\n) {\n  assert(props.id === prevProps.id, 'source id changed');\n  assert(props.type === prevProps.type, 'source type changed');\n\n  let changedKey = '';\n  let changedKeyCount = 0;\n\n  for (const key in props) {\n    if (key !== 'children' && key !== 'id' && !deepEqual(prevProps[key], props[key])) {\n      changedKey = key;\n      changedKeyCount++;\n    }\n  }\n\n  if (!changedKeyCount) {\n    return;\n  }\n\n  const type = props.type;\n\n  if (type === 'geojson') {\n    (source as GeoJSONSourceImplementation).setData(\n      (props as unknown as GeoJSONSourceRaw).data as any\n    );\n  } else if (type === 'image') {\n    (source as ImageSourceImplemtation).updateImage({\n      url: (props as unknown as ImageSourceRaw).url,\n      coordinates: (props as unknown as ImageSourceRaw).coordinates\n    });\n  } else if ('setCoordinates' in source && changedKeyCount === 1 && changedKey === 'coordinates') {\n    source.setCoordinates((props as ImageSourceRaw).coordinates);\n  } else if ('setUrl' in source && changedKey === 'url') {\n    source.setUrl((props as VectorSourceRaw).url);\n  } else if ('setTiles' in source && changedKey === 'tiles') {\n    source.setTiles((props as VectorSourceRaw).tiles);\n  } else {\n    // eslint-disable-next-line\n    console.warn(`Unable to update <Source> prop: ${changedKey}`);\n  }\n}\n/* eslint-enable complexity */\n\nfunction Source<SourceT extends ISource>(props: SourceProps<SourceT>) {\n  const map = useContext(MapContext).map.getMap();\n  const propsRef = useRef(props);\n  const [, setStyleLoaded] = useState(0);\n\n  const id = useMemo(() => props.id || `jsx-source-${sourceCounter++}`, []);\n\n  useEffect(() => {\n    if (map) {\n      /* global setTimeout */\n      const forceUpdate = () => setTimeout(() => setStyleLoaded(version => version + 1), 0);\n      map.on('styledata', forceUpdate);\n      forceUpdate();\n\n      return () => {\n        map.off('styledata', forceUpdate);\n        // @ts-ignore\n        if (map.style && map.style._loaded && map.getSource(id)) {\n          // Parent effects are destroyed before child ones, see\n          // https://github.com/facebook/react/issues/16728\n          // Source can only be removed after all child layers are removed\n          const allLayers = map.getStyle()?.layers;\n          if (allLayers) {\n            for (const layer of allLayers) {\n              // @ts-ignore (2339) source does not exist on all layer types\n              if (layer.source === id) {\n                map.removeLayer(layer.id);\n              }\n            }\n          }\n          map.removeSource(id);\n        }\n      };\n    }\n    return undefined;\n  }, [map]);\n\n  // @ts-ignore\n  let source = map && map.style && map.getSource(id);\n  if (source) {\n    updateSource(source, props, propsRef.current);\n  } else {\n    source = createSource(map, id, props);\n  }\n  propsRef.current = props;\n\n  return (\n    (source &&\n      React.Children.map(\n        props.children,\n        child =>\n          child &&\n          cloneElement(child, {\n            source: id\n          })\n      )) ||\n    null\n  );\n}\n\nexport default Source;\n","import * as React from 'react';\nimport type {\n  Map as MapboxMap,\n  MapboxOptions,\n  Marker as MapboxMarker,\n  MarkerOptions,\n  Popup as MapboxPopup,\n  PopupOptions,\n  AttributionControl as MapboxAttributionControl,\n  FullscreenControl as MapboxFullscreenControl,\n  GeolocateControl as MapboxGeolocateControl,\n  NavigationControl as MapboxNavigationControl,\n  ScaleControl as MapboxScaleControl\n} from 'mapbox-gl';\nimport {MapStyle, AnyLayer, AnySource} from './types/style-spec-mapbox';\n\nimport {default as _Map, MapProps as _MapProps} from './components/map';\nimport {default as _Marker, MarkerProps as _MarkerProps} from './components/marker';\nimport {default as _Popup, PopupProps as _PopupProps} from './components/popup';\nimport {\n  default as _AttributionControl,\n  AttributionControlProps as _AttributionControlProps\n} from './components/attribution-control';\nimport {\n  default as _FullscreenControl,\n  FullscreenControlProps as _FullscreenControlProps\n} from './components/fullscreen-control';\nimport {\n  default as _GeolocateControl,\n  GeolocateControlProps as _GeolocateControlProps\n} from './components/geolocate-control';\nimport {\n  default as _NavigationControl,\n  NavigationControlProps as _NavigationControlProps\n} from './components/navigation-control';\nimport {\n  default as _ScaleControl,\n  ScaleControlProps as _ScaleControlProps\n} from './components/scale-control';\nimport {default as _Layer, LayerProps as _LayerProps} from './components/layer';\nimport {default as _Source, SourceProps as _SourceProps} from './components/source';\nimport {useMap as _useMap} from './components/use-map';\nimport type {MapRef as _MapRef} from './mapbox/create-ref';\nimport type * as events from './types/events';\nimport type {MapCallbacks} from './types/events-mapbox';\n\nexport function useMap() {\n  return _useMap<MapboxMap>();\n}\n\nexport type MapProps = _MapProps<MapboxOptions, MapStyle, MapCallbacks, MapboxMap>;\nexport type MapRef = _MapRef<MapboxMap>;\nconst mapLib = import('mapbox-gl');\nexport const Map = (() => {\n  return React.forwardRef(function Map(props: MapProps, ref: React.Ref<MapRef>) {\n    return _Map<MapboxOptions, MapStyle, MapCallbacks, MapboxMap>(props, ref, mapLib);\n  });\n})();\n\nexport type MarkerProps = _MarkerProps<MarkerOptions, MapboxMarker>;\nexport const Marker = _Marker as (\n  props: MarkerProps & React.RefAttributes<MapboxMarker>\n) => React.ReactElement | null;\n\nexport type PopupProps = _PopupProps<PopupOptions, MapboxPopup>;\nexport const Popup = _Popup as (\n  props: PopupProps & React.RefAttributes<MapboxPopup>\n) => React.ReactElement | null;\n\ntype AttributionControlOptions = ConstructorParameters<typeof MapboxAttributionControl>[0];\nexport type AttributionControlProps = _AttributionControlProps<AttributionControlOptions>;\nexport const AttributionControl = _AttributionControl as (\n  props: AttributionControlProps\n) => React.ReactElement | null;\n\ntype FullscreenControlOptions = ConstructorParameters<typeof MapboxFullscreenControl>[0];\nexport type FullscreenControlProps = _FullscreenControlProps<FullscreenControlOptions>;\nexport const FullscreenControl = _FullscreenControl as (\n  props: FullscreenControlProps\n) => React.ReactElement | null;\n\ntype NavigationControlOptions = ConstructorParameters<typeof MapboxNavigationControl>[0];\nexport type NavigationControlProps = _NavigationControlProps<NavigationControlOptions>;\nexport const NavigationControl = _NavigationControl as (\n  props: NavigationControlProps\n) => React.ReactElement | null;\n\ntype GeolocateControlOptions = ConstructorParameters<typeof MapboxGeolocateControl>[0];\nexport type GeolocateControlProps = _GeolocateControlProps<\n  GeolocateControlOptions,\n  MapboxGeolocateControl\n>;\nexport const GeolocateControl = _GeolocateControl as (\n  props: GeolocateControlProps & React.RefAttributes<MapboxGeolocateControl>\n) => React.ReactElement | null;\n\ntype ScaleControlOptions = ConstructorParameters<typeof MapboxScaleControl>[0];\nexport type ScaleControlProps = _ScaleControlProps<ScaleControlOptions>;\nexport const ScaleControl = _ScaleControl as (\n  props: ScaleControlProps\n) => React.ReactElement | null;\n\nexport type LayerProps = _LayerProps<AnyLayer>;\nexport const Layer = _Layer as (props: LayerProps) => React.ReactElement | null;\n\nexport type SourceProps = _SourceProps<AnySource>;\nexport const Source = _Source as (props: SourceProps) => React.ReactElement | null;\n\nexport {default as useControl} from './components/use-control';\nexport {MapProvider} from './components/use-map';\n\nexport default Map;\n\n// Types\nexport * from './types/public';\nexport type {\n  Point,\n  PointLike,\n  LngLat,\n  LngLatLike,\n  LngLatBounds,\n  LngLatBoundsLike,\n  PaddingOptions,\n  MapboxGeoJSONFeature as MapGeoJSONFeature,\n  GeoJSONSource,\n  VideoSource,\n  ImageSource,\n  CanvasSource,\n  VectorSourceImpl as VectorTileSource\n} from 'mapbox-gl';\nexport * from './types/style-spec-mapbox';\n\n// Events\nexport type {\n  MapEvent,\n  MapMouseEvent,\n  MapLayerMouseEvent,\n  MapTouchEvent,\n  MapLayerTouchEvent,\n  MapStyleDataEvent,\n  MapSourceDataEvent,\n  MapWheelEvent,\n  MapBoxZoomEvent,\n  ErrorEvent,\n  ViewStateChangeEvent\n} from './types/events-mapbox';\nexport type PopupEvent = events.PopupEvent<MapboxPopup>;\nexport type MarkerEvent = events.MarkerEvent<MapboxMarker>;\nexport type MarkerDragEvent = events.MarkerDragEvent<MapboxMarker>;\nexport type GeolocateEvent = events.GeolocateEvent<MapboxGeolocateControl>;\nexport type GeolocateResultEvent = events.GeolocateResultEvent<MapboxGeolocateControl>;\nexport type GeolocateErrorEvent = events.GeolocateErrorEvent<MapboxGeolocateControl>;\n\n// v7.0 backward compatibility\n\n/** @deprecated use `MapStyle` */\nexport type MapboxStyle = MapStyle;\n\nexport type {Map as MapboxMap, MapboxEvent, MapboxGeoJSONFeature} from 'mapbox-gl';\n"],"names":["MountedMapsContext","React","deepEqual","a","b","Array","isArray","length","i","aKeys","Object","keys","bKeys","key","hasOwnProperty","syncProjection","src","dest","getProjection","srcProjection","setProjection","transformToViewState","tr","longitude","center","lng","latitude","lat","zoom","pitch","bearing","padding","applyViewStateToTransform","props","v","viewState","changed","isPaddingEqual","constructor","refProps","normalizeStyle","style","toJS","layers","layerIndex","layer","id","map","normalizedLayer","assign","interactive","layerRef","ref","propName","DEFAULT_STYLE","version","sources","pointerEvents","mousedown","mouseup","mouseover","mousemove","click","dblclick","mouseenter","mouseleave","mouseout","contextmenu","touchstart","touchend","touchmove","touchcancel","cameraEvents","movestart","move","moveend","dragstart","drag","dragend","zoomstart","zoomend","rotatestart","rotate","rotateend","pitchstart","pitchend","otherEvents","wheel","boxzoomstart","boxzoomend","boxzoomcancel","resize","load","render","idle","remove","data","styledata","sourcedata","error","settingNames","handlerNames","Mapbox","MapClass","container","_map","_internalUpdate","_inRender","_hoveredFeatures","_deferredEvents","_onEvent","e","cb","this","type","console","_onPointerEvent","_updateHover","interactiveLayerIds","features","_queryRenderedFeatures","point","_onCameraEvent","_MapClass","_initialize","transform","_renderTransform","setProps","oldProps","settingsChanged","_updateSettings","_createShadowTransform","sizeChanged","_updateSize","viewStateChanged","_updateViewState","_updateStyle","_updateStyleComponents","_updateHandlers","isMoving","redraw","reuse","that","savedMaps","pop","oldContainer","getContainer","className","childNodes","appendChild","_container","resizeObserver","_resizeObserver","disconnect","observe","styleDiffing","initialViewState","bounds","fitBounds","fitBoundsOptions","duration","isStyleLoaded","fire","once","_update","mapStyle","mapOptions","accessToken","mapboxAccessToken","getAccessTokenFromEnv","gl","getContext","HTMLCanvasElement","prototype","setPadding","cursor","getCanvas","renderMap","_render","arg","call","runRenderTaskQueue","_renderTaskQueue","run","_onBeforeRepaint","on","_onAfterRepaint","fireEvent","_fireEvent","bind","width","height","eventName","recycle","children","querySelector","push","destroy","_frame","cancel","renderTransform","newTransform","clone","pixelsToGLUnits","cloneTransform","painter","nextProps","triggerEvents","cameraElevationReference","deferredEvents","currProps","setter","toUpperCase","slice","options","diff","localIdeographFontFamily","setStyle","setLight","light","setFog","fog","setTerrain","terrain","getSource","source","newValue","_a","_b","enable","disable","queryRenderedFeatures","filter","getLayer","onMouseMove","onMouseEnter","onMouseLeave","eventType","wasHovering","isHovering","baseFire","event","properties","location","match","exec","search","process","MapboxAccessToken","REACT_APP_MAPBOX_ACCESS_TOKEN","skipMethods","createRef","mapInstance","result","getMap","getCenter","getZoom","getBearing","getPitch","getPadding","getBounds","project","lnglat","unproject","queryTerrainElevation","geometry","obj","Set","proto","getOwnPropertyNames","add","getPrototypeOf","from","getMethodNames","includes","document","useLayoutEffect","useEffect","globalSettings","MapContext","Map","defaultLib","mountedMapsContext","useContext","setMapInstance","useState","containerRef","useRef","current","contextValue","mapLib","mapbox","isMounted","Promise","resolve","then","module","Error","mapboxgl","default","RTLTextPlugin","getRTLTextPluginStatus","setRTLTextPlugin","setGlobals","supported","reuseMaps","onMapMount","catch","onError","target","originalEvent","onMapUnmount","useIsomorphicLayoutEffect","useImperativeHandle","useMemo","position","Provider","value","unitlessNumber","applyReactStyle","element","styles","Number","isFinite","test","memo","forwardRef","thisRef","marker","hasChildren","forEach","el","createElement","mk","Marker","setLngLat","getElement","addEventListener","onClick","evt","lngLat","getLngLat","onDragStart","onDrag","onDragEnd","addTo","offset","draggable","popup","rotation","rotationAlignment","pitchAlignment","ax","x","ay","y","bx","by","arePointsEqual","getOffset","setOffset","isDraggable","setDraggable","getRotation","setRotation","getRotationAlignment","setRotationAlignment","getPitchAlignment","setPitchAlignment","getPopup","setPopup","createPortal","getClassList","trim","split","pp","Popup","onOpen","onClose","setDOMContent","off","isOpen","anchor","maxWidth","setMaxWidth","prevClassList","nextClassList","c","has","removeClassName","addClassName","onCreate","arg1","arg2","arg3","context","ctrl","opts","onAdd","onRemove","hasControl","addControl","removeControl","useControl","_ref","AttributionControl","FullscreenControl","containerId","getElementById","_controlContainer","gc","GeolocateControl","setupUI","_setupUI","args","hasChildNodes","onGeolocate","onOutOfMaxBounds","onTrackUserLocationStart","onTrackUserLocationEnd","NavigationControl","ScaleControl","propsRef","prevProps","undefined","unit","setUnit","assert","condition","message","layerCounter","setStyleLoaded","forceUpdate","_loaded","removeLayer","layout","paint","minzoom","maxzoom","beforeId","moveLayer","prevLayout","setLayoutProperty","prevPaint","setPaintProperty","setFilter","setLayerZoomRange","updateLayer","warn","addLayer","createLayer","sourceCounter","setTimeout","allLayers","getStyle","removeSource","changedKey","changedKeyCount","setData","updateImage","url","coordinates","setCoordinates","setUrl","setTiles","tiles","updateSource","addSource","createSource","child","cloneElement","_Map","_Marker","_Popup","_FullscreenControl","_NavigationControl","_GeolocateControl","_ScaleControl","Layer","_Layer","Source","_Source"],"sourceRoot":""}